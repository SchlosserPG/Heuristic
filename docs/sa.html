<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Pamela Schlosser">

<title>Simulated Annealing ‚Äì Heuristic Algorithms</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./ga.html" rel="next">
<link href="./hc.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2486e1f0a3ee9ee1fc393803a1361cdb.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-64b801fe9b6685c0a799f7172ecad621.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<!-- Google tag (gtag.js) -->

<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-XC0ZP42MWM"></script>

<script>

  window.dataLayer = window.dataLayer || [];

  function gtag(){dataLayer.push(arguments);}

  gtag('js', new Date());



  gtag('config', 'G-XC0ZP42MWM');

</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./sa.html"><span class="chapter-title">Simulated Annealing</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Heuristic Algorithms</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Introduction to Heuristic Algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./algo.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Algorithm Design and Pseudocode</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./numpy.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Python for Heuristics &amp; NumPy</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./greedy.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Introduction to Greedy Algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./benchmark.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Benchmark Optimization Problems</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./es.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Exhaustive Search</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./hc.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Hill Climbing</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./sa.html" class="sidebar-item-text sidebar-link active"><span class="chapter-title">Simulated Annealing</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ga.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Genetic Algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./summary.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Summary</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Required Reading Materials</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#what-is-a-metaheuristic-algorithm" id="toc-what-is-a-metaheuristic-algorithm" class="nav-link active" data-scroll-target="#what-is-a-metaheuristic-algorithm">What is a Metaheuristic Algorithm?</a>
  <ul class="collapse">
  <li><a href="#history-of-metaheuristics" id="toc-history-of-metaheuristics" class="nav-link" data-scroll-target="#history-of-metaheuristics">History of Metaheuristics</a></li>
  <li><a href="#a-unified-framework-for-metaheuristic-algorithms-ufm" id="toc-a-unified-framework-for-metaheuristic-algorithms-ufm" class="nav-link" data-scroll-target="#a-unified-framework-for-metaheuristic-algorithms-ufm">A Unified Framework for Metaheuristic Algorithms (UFM)</a></li>
  <li><a href="#ufm-5-main-operators" id="toc-ufm-5-main-operators" class="nav-link" data-scroll-target="#ufm-5-main-operators">UFM 5 Main Operators</a></li>
  <li><a href="#ufm" id="toc-ufm" class="nav-link" data-scroll-target="#ufm">UFM</a></li>
  <li><a href="#comparison-between-exhaustive-search-greedy-and-metaheuristic-algorithms" id="toc-comparison-between-exhaustive-search-greedy-and-metaheuristic-algorithms" class="nav-link" data-scroll-target="#comparison-between-exhaustive-search-greedy-and-metaheuristic-algorithms">Comparison between exhaustive search, greedy, and metaheuristic algorithms</a></li>
  </ul></li>
  <li><a href="#simulated-annealing-sa" id="toc-simulated-annealing-sa" class="nav-link" data-scroll-target="#simulated-annealing-sa">Simulated Annealing (SA)</a>
  <ul class="collapse">
  <li><a href="#key-components" id="toc-key-components" class="nav-link" data-scroll-target="#key-components">Key Components</a></li>
  <li><a href="#defining-sa" id="toc-defining-sa" class="nav-link" data-scroll-target="#defining-sa">Defining SA</a></li>
  <li><a href="#usefulness-of-sa" id="toc-usefulness-of-sa" class="nav-link" data-scroll-target="#usefulness-of-sa">Usefulness of SA</a></li>
  <li><a href="#tuning-parameters" id="toc-tuning-parameters" class="nav-link" data-scroll-target="#tuning-parameters">Tuning Parameters</a></li>
  <li><a href="#the-search-strategy-of-sa" id="toc-the-search-strategy-of-sa" class="nav-link" data-scroll-target="#the-search-strategy-of-sa">The Search Strategy of SA</a></li>
  <li><a href="#sa-algorithm" id="toc-sa-algorithm" class="nav-link" data-scroll-target="#sa-algorithm">SA Algorithm</a></li>
  <li><a href="#many-versions-of-sa-exist" id="toc-many-versions-of-sa-exist" class="nav-link" data-scroll-target="#many-versions-of-sa-exist">Many Versions of SA Exist</a></li>
  <li><a href="#advantages-and-disadvantages-of-sa" id="toc-advantages-and-disadvantages-of-sa" class="nav-link" data-scroll-target="#advantages-and-disadvantages-of-sa">Advantages and Disadvantages of SA</a>
  <ul class="collapse">
  <li><a href="#advantages" id="toc-advantages" class="nav-link" data-scroll-target="#advantages">Advantages</a></li>
  <li><a href="#disadvantages" id="toc-disadvantages" class="nav-link" data-scroll-target="#disadvantages">Disadvantages</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sa-algorithm-1" id="toc-sa-algorithm-1" class="nav-link" data-scroll-target="#sa-algorithm-1">SA Algorithm</a>
  <ul class="collapse">
  <li><a href="#examples-of-how-value-can-change" id="toc-examples-of-how-value-can-change" class="nav-link" data-scroll-target="#examples-of-how-value-can-change">Examples of How Value Can Change</a>
  <ul class="collapse">
  <li><a href="#summary-of-cases" id="toc-summary-of-cases" class="nav-link" data-scroll-target="#summary-of-cases">Summary of Cases</a></li>
  </ul></li>
  <li><a href="#comparing-algorithms" id="toc-comparing-algorithms" class="nav-link" data-scroll-target="#comparing-algorithms">Comparing Algorithms</a>
  <ul class="collapse">
  <li><a href="#when-sa-is-more-appropriate" id="toc-when-sa-is-more-appropriate" class="nav-link" data-scroll-target="#when-sa-is-more-appropriate">When SA Is More Appropriate</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#making-a-model-one-max-with-sa" id="toc-making-a-model-one-max-with-sa" class="nav-link" data-scroll-target="#making-a-model-one-max-with-sa">Making a Model: One Max with SA</a>
  <ul class="collapse">
  <li><a href="#imports-global-variables" id="toc-imports-global-variables" class="nav-link" data-scroll-target="#imports-global-variables">Imports, Global Variables</a></li>
  <li><a href="#initialize" id="toc-initialize" class="nav-link" data-scroll-target="#initialize">Initialize</a>
  <ul class="collapse">
  <li><a href="#transition-t" id="toc-transition-t" class="nav-link" data-scroll-target="#transition-t">Transition (T)</a></li>
  <li><a href="#evaluate-e" id="toc-evaluate-e" class="nav-link" data-scroll-target="#evaluate-e">Evaluate (E)</a></li>
  <li><a href="#determination-d" id="toc-determination-d" class="nav-link" data-scroll-target="#determination-d">Determination (D)</a></li>
  <li><a href="#run-function" id="toc-run-function" class="nav-link" data-scroll-target="#run-function">Run Function</a></li>
  <li><a href="#main-execution" id="toc-main-execution" class="nav-link" data-scroll-target="#main-execution">Main Execution</a></li>
  </ul></li>
  <li><a href="#output" id="toc-output" class="nav-link" data-scroll-target="#output">Output</a></li>
  </ul></li>
  <li><a href="#sa-with-ackley-function" id="toc-sa-with-ackley-function" class="nav-link" data-scroll-target="#sa-with-ackley-function">SA with Ackley Function</a>
  <ul class="collapse">
  <li><a href="#example-results" id="toc-example-results" class="nav-link" data-scroll-target="#example-results">Example Results</a>
  <ul class="collapse">
  <li><a href="#comparing-sa-to-hc-with-ackley-function" id="toc-comparing-sa-to-hc-with-ackley-function" class="nav-link" data-scroll-target="#comparing-sa-to-hc-with-ackley-function">Comparing SA to HC with Ackley Function</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#portfolio-diversification-with-sa" id="toc-portfolio-diversification-with-sa" class="nav-link" data-scroll-target="#portfolio-diversification-with-sa">Portfolio Diversification With SA</a>
  <ul class="collapse">
  <li><a href="#which-model-is-better" id="toc-which-model-is-better" class="nav-link" data-scroll-target="#which-model-is-better">Which Model is Better</a></li>
  </ul></li>
  <li><a href="#using-ai" id="toc-using-ai" class="nav-link" data-scroll-target="#using-ai">Using AI</a>
  <ul class="collapse">
  <li><a href="#conclusions" id="toc-conclusions" class="nav-link" data-scroll-target="#conclusions">Conclusions</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-title">Simulated Annealing</span></h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Pamela Schlosser </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="what-is-a-metaheuristic-algorithm" class="level1">
<h1>What is a Metaheuristic Algorithm?</h1>
<ul>
<li>One of the main attributes of a metaheuristic algorithm is that it performs a certain set of operators for a certain number of iterations to search for the optimal solution with great shrewdness.</li>
<li>Compared to the Exhaustive Search (ES) and hill climbing (HC) algorithms, a metaheuristic algorithm will neither check all the candidate solutions of a complex optimization problem like ES nor fall into a local optimum at early iterations as easily as HC.</li>
</ul>
<section id="history-of-metaheuristics" class="level2">
<h2 class="anchored" data-anchor-id="history-of-metaheuristics">History of Metaheuristics</h2>
<ul>
<li>Although the term ‚Äúmetaheuristic‚Äù was introduced in the 1980s, several metaheuristic algorithms were actually presented in the 1960s or even earlier.</li>
<li>The year 1990 can be regarded as the first watershed in the development of metaheuristic algorithms. However, the available computing power may not satisfy the requirements of some complicated metaheuristic algorithms.</li>
<li>Since the late 1990s, the number of metaheuristic algorithms has exploded. More and more studies use ‚Äúthe number of evaluations‚Äù to replace ‚Äúthe number of iterations‚Äù for evaluating the performance of a metaheuristic algorithm because each search can be regarded as an investment of computation resource.
<ul>
<li>Using the number of evaluations provides a way that is more precise than using the number of iterations to evaluate the effect (improvement or outcome) of adding an additional unit of computation resource for the search</li>
</ul></li>
<li>From the year 2010 or even earlier, some groups have attempted to apply metaheuristic algorithms in high-performance computing environments.
<ul>
<li>Using distributed or parallel computing systems to accelerate the response time of metaheuristic algorithms is an intuitive approach adopted in some early studies.</li>
<li>Some of the parallel metaheuristics are not only able to provide the end results to the user more quickly; they also can find better results than metaheuristic algorithms on a single machine because the parallel computing mechanism leads them to increase the search diversity during the convergence process.</li>
<li>When we look at these distributed and parallel computing environments, the cloud computing platform (e.g., Hadoop, Spark, Microsoft Azure, Amazon EC2, or Google Compute Engine) can now provide an easy way to use a distributed computing system to further reduce the response time of metaheuristics.</li>
</ul></li>
</ul>
</section>
<section id="a-unified-framework-for-metaheuristic-algorithms-ufm" class="level2">
<h2 class="anchored" data-anchor-id="a-unified-framework-for-metaheuristic-algorithms-ufm">A Unified Framework for Metaheuristic Algorithms (UFM)</h2>
<ul>
<li>The appearance of metaheuristic algorithms has come with methods to classify them. These classification methods include:</li>
</ul>
<ol type="1">
<li>nature-inspired vs.&nbsp;non-nature inspired,</li>
<li>dynamic vs.&nbsp;static objective function,</li>
<li>one vs.&nbsp;various neighborhood structures,</li>
<li>memory usage vs.&nbsp;memoryless methods,</li>
<li>with vs.&nbsp;without local search method, and</li>
<li>population-based vs.&nbsp;single-solution-based search.</li>
</ol>
</section>
<section id="ufm-5-main-operators" class="level2">
<h2 class="anchored" data-anchor-id="ufm-5-main-operators">UFM 5 Main Operators</h2>
<ol type="1">
<li>Initialization (I): The initialization operator normally plays the roles of reading the input file (e.g., dataset), initializing all the parameters of a metaheuristic algorithm, and determining the initial solutions, which is normally based on a random process.</li>
<li>Transition (T): The transition operator usually plays the role of varying the search directions, such as perturbing a portion of the subsolutions of the current solution to generate a new candidate solution or generating a set of new candidate solutions each based on two or more of the current solutions.</li>
<li>Evaluation (E): The evaluation operator is responsible for measuring the quality of solutions, such as calculating the objective value of each solution to be used by the determination operator to distinguish the quality of all the solutions. An intuitive way is to use an objective function to measure the quality of a solution for the problem in question. However, some metaheuristics do not use the ‚Äúobjective value‚Äù directly to measure their solutions; rather, the objective value of a solution has to undergo some sort of transformation to obtain the so-called ‚Äúfitness value.‚Äù</li>
<li>Determination (D): The determination operator plays the role of deciding the search directions by using information the evaluation operator provides during the convergence process. The performance of a metaheuristic algorithm depends to a large extent on the performance of this operator. A ‚Äúgood‚Äù search strategy for this operator will make it possible for the metaheuristic algorithm to find a better solution faster or to avoid falling into a local optimum at early iterations.</li>
<li>Output (O): In spite of the fact that this operator seems to be trivial, the reality is that it can be either simple or complex depending on how much information we want to display for the metaheuristic algorithm. It can be as simple as displaying only the final result of the metaheuristic algorithm, or it can be as complex as displaying the trajectory of convergence of the metaheuristic algorithm to better understand the performance of a metaheuristic algorithm.</li>
</ol>
</section>
<section id="ufm" class="level2">
<h2 class="anchored" data-anchor-id="ufm">UFM</h2>
<ul>
<li>In this framework, I denotes the input dataset, s denotes the current solution, <span class="math inline">\(\nu\)</span> denotes the candidate solution, <span class="math inline">\(f_s\)</span> denotes the objective value of <span class="math inline">\(s\)</span>, and <span class="math inline">\(f_\nu\)</span> denotes the objective value of <span class="math inline">\(\nu\)</span>. Also, <span class="math inline">\(s\)</span> and <span class="math inline">\(\nu\)</span> can denote either a single solution or a set of solutions, where each solution has <span class="math inline">\(n\)</span> elements or is an <span class="math inline">\(n-tuple\)</span>.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Pictures/UFM.png" title="UFM" class="img-fluid figure-img"></p>
<figcaption>UFM</figcaption>
</figure>
</div>
</section>
<section id="comparison-between-exhaustive-search-greedy-and-metaheuristic-algorithms" class="level2">
<h2 class="anchored" data-anchor-id="comparison-between-exhaustive-search-greedy-and-metaheuristic-algorithms">Comparison between exhaustive search, greedy, and metaheuristic algorithms</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Pictures/compare.png" title="Compare Models" class="img-fluid figure-img"></p>
<figcaption>Compare Models</figcaption>
</figure>
</div>
</section>
</section>
<section id="simulated-annealing-sa" class="level1">
<h1>Simulated Annealing (SA)</h1>
<p><strong>If life is like simulated annealing, what‚Äôs the most memorable ‚Äòtemperature drop‚Äô moment where you had to settle down and stick to one choice?</strong></p>
<ul>
<li><p>A single-solution-based algorithm</p></li>
<li><p>A probabilistic optimization algorithm inspired by the annealing process in metallurgy, where materials are heated and then slowly cooled to reduce defects, thereby optimizing their structural properties.</p></li>
<li><p>In optimization, SA is used to find a good approximation to the global minimum or maximum of a function in a large search space, particularly when the search space is discrete or contains multiple local minima.</p></li>
<li><p>The search strategy of SA is to start with a random possible solution in the solution space and then use the Metropolis acceptance criterion to determine whether a worse solution is to be accepted or not.</p></li>
<li><p>To emulate the annealing process for a minimization optimization problem, SA will first calculate the difference between the objective values of the new candidate solution <span class="math inline">\(\nu\)</span> and the current solution <span class="math inline">\(s\)</span> to see whether it will accept the new candidate solution or not, as follows: <span class="math inline">\(\Delta_f^{\text{min}} = f(\nu) - f(s)\)</span></p></li>
</ul>
<section id="key-components" class="level2">
<h2 class="anchored" data-anchor-id="key-components">Key Components</h2>
<ul>
<li>Solution Space:
<ul>
<li>This is the space of all possible solutions to the problem.</li>
</ul></li>
<li>Objective Function:
<ul>
<li>Defines the quality and overall goal of a solution.</li>
</ul></li>
<li>Temperature:
<ul>
<li>This controls the probability of accepting worse solutions.</li>
<li>Initially, the temperature is high, allowing the algorithm to explore the solution space more freely.</li>
<li>As the temperature lowers, the algorithm becomes more conservative, accepting only smaller degradations in the objective.</li>
</ul></li>
<li>Cooling Schedule:
<ul>
<li>This is a function that dictates how the temperature decreases over time (iterations).</li>
<li>Typically, it follows a geometric decay, where the temperature decreases by a factor on each iteration (e.g., <span class="math inline">\(T = T_0 * \alpha^k\)</span>, where <span class="math inline">\(T_0\)</span> is the initial temperature, alpha is a constant, and <span class="math inline">\(k\)</span> is the iteration number).</li>
</ul></li>
</ul>
</section>
<section id="defining-sa" class="level2">
<h2 class="anchored" data-anchor-id="defining-sa">Defining SA</h2>
<ul>
<li>An iterative algorithm that explores the solution space of an optimization problem by considering not only improvements to the current solution but also occasional, controlled acceptance of worse solutions. This allows the algorithm to escape local minima and explore a broader range of the search space in search of a global minimum.
<ul>
<li>The function <span class="math inline">\(f(x)\)</span> that the algorithm seeks to minimize (or maximize)</li>
<li>The configuration or state is a point <span class="math inline">\(x\)</span> in the solution space, representing a possible solution to the problem.</li>
<li>The neighboring states are the set of solutions that are reachable from the current state through small modifications.</li>
<li>A control parameter temperature <span class="math inline">\(T\)</span>) that regulates the likelihood of accepting worse solutions. It starts high and gradually decreases as the algorithm progresses.</li>
<li>As <span class="math inline">\(T\)</span> decreases, the probability of accepting worse solutions decreases, making the search more focused on local improvements.</li>
<li>A cooling schedule includes a function that controls the decrease of the temperature T over time</li>
</ul></li>
</ul>
</section>
<section id="usefulness-of-sa" class="level2">
<h2 class="anchored" data-anchor-id="usefulness-of-sa">Usefulness of SA</h2>
<ul>
<li>The basic idea of SA is to occasionally accept non-improving solutions, which means that SA will not always move to a better solution.</li>
<li>Simulated Annealing is widely used in various fields, such as:
<ul>
<li>Combinatorial Optimization: Problems like the Traveling Salesman Problem (TSP), scheduling, and circuit design.</li>
<li>Machine Learning: Hyperparameter optimization, clustering.</li>
<li>Engineering: Structural design, control systems.</li>
</ul></li>
<li>Practical Applications: real-world problems where SA shines: vehicle routing, job scheduling, or portfolio optimization.</li>
</ul>
</section>
<section id="tuning-parameters" class="level2">
<h2 class="anchored" data-anchor-id="tuning-parameters">Tuning Parameters</h2>
<ul>
<li>The success of SA heavily depends on the tuning of parameters like the cooling schedule, the initial temperature, and the size of the neighborhood.</li>
<li>In the context of tuning parameters for Simulated Annealing (SA), the exploration-exploitation trade-off means adjusting the algorithm‚Äôs behavior to balance between searching broadly (exploration) and refining promising solutions (exploitation).</li>
</ul>
</section>
<section id="the-search-strategy-of-sa" class="level2">
<h2 class="anchored" data-anchor-id="the-search-strategy-of-sa">The Search Strategy of SA</h2>
<ul>
<li>The search strategy of SA is to start with a random possible solution in the solution space and then use a criteria (like the metropolis acceptance criterion) to determine whether a worse solution is to be accepted or not.</li>
<li>In this example, <span class="math inline">\(t^{\Delta} \quad\)</span> and <span class="math inline">\(\quad t^{\nabla}\)</span> indicate that the solution at the <span class="math inline">\(t+1^{\text{th}}\)</span> iteration is either better or not better than the solution at the <span class="math inline">\(t^{\text{th}}\)</span> iteration, respectively.</li>
<li>This example shows that if the starting point is ùë•_9 and SA accepts only a new candidate solution that is better than the current solution, i.e., it has no escape mechanism, the search will get stuck at one of the two local optima (<span class="math inline">\(x_8\)</span> and <span class="math inline">\(x_10\)</span>) denoted <span class="math inline">\(L_1\)</span> and <span class="math inline">\(L_2\)</span>.</li>
<li>The temperature parameter in SA allows escape from local optima. If the search starts at <span class="math inline">\(x_9\)</span>, SA can potentially move to worse solutions with a certain probability based on temperature and a random probability check. At higher temperatures, SA has a higher chance of escaping local optima (<span class="math inline">\(L_1\)</span>) (<span class="math inline">\(x_8\)</span>) and (<span class="math inline">\(L_2\)</span>) (<span class="math inline">\(x_{10}\)</span>), but as the temperature decreases, it becomes less likely to accept worse moves, leading to convergence.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Pictures/sa.png" title="Search Strategy of SA" class="img-fluid figure-img"></p>
<figcaption>Search Strategy of SA</figcaption>
</figure>
</div>
</section>
<section id="sa-algorithm" class="level2">
<h2 class="anchored" data-anchor-id="sa-algorithm">SA Algorithm</h2>
<ul>
<li>Initialization:
<ul>
<li>Choose an initial solution <span class="math inline">\(s\)</span> and an initial temperature <span class="math inline">\(T_0\)</span>.</li>
</ul></li>
<li>Iteration:
<ul>
<li>For each step, generate a neighboring solution <span class="math inline">\(v\)</span> of the current solution <span class="math inline">\(s\)</span>.</li>
<li>Compute the change in the objective function.</li>
<li>Decide whether to move to the new solution <span class="math inline">\(v\)</span> based on the acceptance probability.</li>
<li>Gradually reduce the temperature <span class="math inline">\(T\)</span> according to the cooling schedule</li>
</ul></li>
<li>Termination:
<ul>
<li>The algorithm stops when the temperature <span class="math inline">\(T\)</span> is sufficiently low or after a predefined number of iterations.</li>
<li>The best solution found during the process is returned.</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Pictures/sa1.png" title="SA Algorithm" class="img-fluid figure-img"></p>
<figcaption>SA Algorithm</figcaption>
</figure>
</div>
</section>
<section id="many-versions-of-sa-exist" class="level2">
<h2 class="anchored" data-anchor-id="many-versions-of-sa-exist">Many Versions of SA Exist</h2>
<ul>
<li>This framework is a little bit different from the model above because there are two loops (outer and inner loops). This implies that a certain number of new candidate solutions will be generated and evaluated before the temperature is updated.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Pictures/sa2.png" title="SA Algorithm Variation" class="img-fluid figure-img"></p>
<figcaption>SA Algorithm Variation</figcaption>
</figure>
</div>
</section>
<section id="advantages-and-disadvantages-of-sa" class="level2">
<h2 class="anchored" data-anchor-id="advantages-and-disadvantages-of-sa">Advantages and Disadvantages of SA</h2>
<section id="advantages" class="level3">
<h3 class="anchored" data-anchor-id="advantages">Advantages</h3>
<ul>
<li>Global Search Capability: Unlike simple greedy algorithms, simulated annealing can escape local minima and potentially find a global minimum.</li>
<li>Flexibility: It can be applied to a wide range of optimization problems, including those with complex, multimodal landscapes.</li>
<li>Simplicity: The algorithm is relatively easy to implement and does not require gradient information, making it suitable for non-differentiable problems.</li>
</ul>
</section>
<section id="disadvantages" class="level3">
<h3 class="anchored" data-anchor-id="disadvantages">Disadvantages</h3>
<ul>
<li>Computational Cost: The method can be slow, particularly for large problem spaces, as it requires many iterations to reach a good solution.</li>
<li>Parameter Sensitivity: The performance of simulated annealing depends heavily on the choice of the cooling schedule, initial temperature, and other parameters.</li>
<li>No Guarantee of Optimality: The algorithm does not guarantee finding the global optimum but rather a good approximation.</li>
</ul>
</section>
</section>
</section>
<section id="sa-algorithm-1" class="level1">
<h1>SA Algorithm</h1>
<ul>
<li><p>To emulate the annealing process for a minimization optimization problem, SA will first calculate the difference between the objective values of the new candidate solution v and the current solution s to see whether it will accept the new candidate solution or not. <span class="math display">\[\Delta_f^{\text{min}} = f(\nu) - f(s)\]</span></p></li>
<li><p>In case the difference between the objective values is less than <span class="math inline">\(0\)</span>, SA will accept the new candidate solution as the current solution, which means that <span class="math inline">\(\nu\)</span> replaces; otherwise, SA will calculate a probability to decide whether or not to accept a non-improving candidate solution.</p></li>
<li><p><span class="math inline">\(p_a^{\text{min}} = \exp \left( \frac{-(f(v) - f(s))}{\Psi_t} \right) = \exp \left( \frac{f(s) - f(v)}{\Psi_t} \right),\)</span> where where <span class="math inline">\(f(x)\)</span> denotes the evaluation function, s denotes the current solution, <span class="math inline">\(\nu\)</span> denotes the new solution, and <span class="math inline">\(\Psi_t\)</span> denotes the temperature at the <span class="math inline">\(t\)</span>-th iteration.</p></li>
<li><p>To apply SA to a maximization optimization problem, all we have to do is to negate the difference with the following: <span class="math display">\[\Delta_f^{\text{max}} -\Delta_f^{\text{min}} = -f(v) - -f(s) = f(s)-f(v)\]</span></p></li>
<li><p>Such a modification makes it possible to check <span class="math inline">\(\Delta_f^{\text{max}}\)</span> in a similar way; that is,<span class="math inline">\(\Delta_f^{\text{max}}&lt;0\)</span>, SA will accept the new candidate solution as the current solution; otherwise, SA will again calculate a probability to decide whether or not to accept a non-improving candidate solution for the following: <span class="math display">\[p_a^{\text{max}} = \exp \left( \frac{-(f(s) - f(v))}{\Psi_t} \right) = \exp \left( \frac{f(v) - f(s)}{\Psi_t} \right)\]</span>.</p></li>
</ul>
<section id="examples-of-how-value-can-change" class="level2">
<h2 class="anchored" data-anchor-id="examples-of-how-value-can-change">Examples of How Value Can Change</h2>
<p><img src="Pictures/sa3.png" title="SA Changing Values" class="img-fluid" alt="SA Changing Values"> * Minimization: + If <span class="math inline">\(\Delta_f^{\text{min}}\)</span> is negative, we always accept (better solution). + If <span class="math inline">\(\Delta_f^{\text{min}}\)</span> is positive, accept with probability <span class="math inline">\(paminp_a^{\text{min}}pamin\)</span>.</p>
<ul>
<li>Maximization:
<ul>
<li>If <span class="math inline">\(\Delta_f^{\text{max}}\)</span> is positive, we always accept (better solution).</li>
<li>If <span class="math inline">\(\Delta_f^{\text{max}}\)</span> is negative, accept with probability <span class="math inline">\(pamaxp_a^{\text{max}}\)</span>.</li>
</ul></li>
<li>In this case, <span class="math inline">\(p_a^{\text{max}}\)</span>=.329 and 0.007 for <span class="math inline">\({\Psi_t}\)</span> = .9 and 0.2, respectively. This indicates that a lower temperature Image implies a smaller probability Image to accept a non-improving candidate solution as the current solution.</li>
<li>The value of <span class="math inline">\(f_s\)</span> goes from 2.0 to 1.1, the value of <span class="math inline">\(p_a^{\text{max}}\)</span> goes from 0.329 up to 0.895. This means that in case <span class="math inline">\(f(\nu)\)</span> is worse than <span class="math inline">\(f(s)\)</span>, a smaller <span class="math inline">\(\Delta_f^{\text{max}}\)</span> implies a higher probability <span class="math inline">\(p_a^{\text{max}}\)</span> to accept a non-improving candidate solution as the current solution.</li>
<li>Higher temperatures} (<span class="math inline">\(\Psi_t = 0.9\)</span>) allow higher acceptance of worse solutions.
<ul>
<li>Example: For <span class="math inline">\(\Delta_f^{\min} = -1.0\)</span>, at <span class="math inline">\(\Psi_t = 0.9\)</span>, <span class="math inline">\(p_a^{\min} = 3.038\)</span>(high).</li>
</ul></li>
<li>Lower temperatures <span class="math inline">\(\Psi_t = 0.2\)</span> reject worse solutions more aggressively.
<ul>
<li>Example: For <span class="math inline">\(\Delta_f^{\min} = -1.0\)</span>, at <span class="math inline">\(\Psi_t = 0.2\)</span>, <span class="math inline">\(p_a^{\min} = 148.413\)</span>, which results in almost no acceptance.</li>
</ul></li>
<li>Acceptance of better solutions} <span class="math inline">\(p_a^{\max}\)</span> is much higher in general but varies based on temperature.
<ul>
<li>For <span class="math inline">\(\Psi_t = 0.9\)</span>, <span class="math inline">\(p_a^{\max} = 0.329\)</span> (highlighted in yellow).</li>
<li>For <span class="math inline">\(\Psi_t = 0.2\)</span>, <span class="math inline">\(p_a^{\max} = 0.007\)</span>, meaning lower temperatures almost never accept bad moves.</li>
</ul></li>
</ul>
<section id="summary-of-cases" class="level3">
<h3 class="anchored" data-anchor-id="summary-of-cases">Summary of Cases</h3>
<ul>
<li>The new solution v is better than the current solution s.
<ul>
<li>SA will always accept the new solution owing to the fact that <span class="math inline">\(P_A\)</span> will always be greater than 1.0 and <span class="math inline">\(r \in [0,1]\)</span> will always be smaller than <span class="math inline">\(P_A\)</span>. The new solution <span class="math inline">\(\nu\)</span> is worse than the current solution <span class="math inline">\(s\)</span>. SA will accept the new solution only if <span class="math inline">\(r &lt; P_A\)</span> , where <span class="math inline">\(r\)</span> is as defined above. The new solution <span class="math inline">\(\nu\)</span> is worse than the current solution s. SA will not accept the new solution because <span class="math inline">\(r \geq P_A\)</span> .</li>
</ul></li>
</ul>
</section>
</section>
<section id="comparing-algorithms" class="level2">
<h2 class="anchored" data-anchor-id="comparing-algorithms">Comparing Algorithms</h2>
<ul>
<li>Simulated Annealing Algorithms
<ul>
<li>Exploration: In the early stages, SA accepts worse solutions with high probability, which allows it to explore the search space more broadly and escape local optima.</li>
<li>Exploitation: As the temperature decreases, the algorithm becomes more conservative and starts focusing on refining the current solution. SA balances exploration and exploitation dynamically as the temperature cools.</li>
<li>Trade-off: SA is particularly good when the solution space is rugged (many local optima) because it has a built-in mechanism (temperature) to transition from exploration to exploitation.</li>
</ul></li>
<li>Genetic Algorithms
<ul>
<li>Exploration: GA uses processes like mutation and crossover to generate new solutions from the current population. Mutation allows for exploration by introducing random changes, while crossover exploits good solutions by combining them.</li>
<li>Exploitation: GA exploits the best solutions through selection and crossover, where solutions with higher fitness are more likely to survive and reproduce.</li>
<li>Trade-off: GA maintains a population of solutions, which helps with exploration, but can sometimes suffer from premature convergence if the population becomes too homogeneous, leading to poor exploitation of potentially better solutions.</li>
</ul></li>
<li>Greedy Algorithms
<ul>
<li>Exploration: Greedy algorithms have very limited exploration. They make the best immediate choice (locally optimal) at each step without considering the broader solution space.</li>
<li>Exploitation: Greedy heuristics are purely exploitative‚Äîthey focus solely on improving the current state as much as possible. They tend to get stuck in local optima because they don‚Äôt explore alternative solutions that might initially look worse but could lead to better outcomes.</li>
<li>Trade-off: A greedy algorithm doesn‚Äôt balance exploration and exploitation well. It is fast and simple but can fail when the problem has many local optima, making it inappropriate for complex problems like TSP or scheduling.</li>
</ul></li>
</ul>
<section id="when-sa-is-more-appropriate" class="level3">
<h3 class="anchored" data-anchor-id="when-sa-is-more-appropriate">When SA Is More Appropriate</h3>
<ul>
<li><p>Rugged Solution Spaces: When there are many local optima (like in the Ackley function or complex scheduling), SA‚Äôs ability to accept worse solutions helps it explore more and avoid local traps.</p></li>
<li><p>Time-Constrained Search: SA can be more useful when you don‚Äôt need an exact global optimum but want a good solution within a reasonable amount of time. The cooling schedule can be adjusted to control how fast the algorithm converges.</p></li>
</ul>
</section>
</section>
</section>
<section id="making-a-model-one-max-with-sa" class="level1">
<h1>Making a Model: One Max with SA</h1>
<section id="imports-global-variables" class="level2">
<h2 class="anchored" data-anchor-id="imports-global-variables">Imports, Global Variables</h2>
<div id="afced1f1" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">##Simulated Annealing One-Max Example</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the necessary global variables</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>num_bits <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>max_evals <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>initial_temp <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>cooling_rate <span class="op">=</span> <span class="fl">0.99</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>min_temp <span class="op">=</span> <span class="fl">0.0001</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="initialize" class="level2">
<h2 class="anchored" data-anchor-id="initialize">Initialize</h2>
<ul>
<li>The init_sa function initializes a random solution (sol) for the One-Max problem by generating a binary array of size num_bits, where each element is randomly set to 0 or 1.</li>
<li>The initial solution is evaluated using the One-Max function (evaluate) to calculate its fitness (i.e., the sum of 1‚Äôs in the array).</li>
<li>The function returns the initial solution and its evaluated fitness.</li>
</ul>
<div id="b8c906d9" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialization function (I)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> init_sa(num_bits):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    sol <span class="op">=</span> np.random.randint(<span class="dv">0</span>, <span class="dv">2</span>, num_bits)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sol, evaluate(sol)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="transition-t" class="level3">
<h3 class="anchored" data-anchor-id="transition-t">Transition (T)</h3>
<ul>
<li>The transit function generates a neighboring solution by flipping a random bit in the current solution.</li>
<li>This is done by randomly selecting an index in the binary array and toggling the bit (changing 1 to 0 or 0 to 1).</li>
<li>This new solution represents the neighboring candidate that will be evaluated next, which is a small random change to the current solution.</li>
</ul>
<div id="cc10c006" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Transition function (T)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> transit(sol):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    new_sol <span class="op">=</span> sol.copy()</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    index <span class="op">=</span> np.random.randint(<span class="bu">len</span>(sol))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    new_sol[index] <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> new_sol[index]  <span class="co"># Flip a random bit</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> new_sol</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li>Example: 1011011001‚Ä¶1100100110 (100 bits total)</li>
<li>Randomly Selected Bit to Flip: Assume random index was 25.
<ul>
<li>New Solution After Flip: If the bit at index = 25 was 1, it flips to 0, and vice versa.</li>
<li>Before: 1011011001‚Ä¶110<strong>0</strong>100110 (Bit at index 25 is <code>0</code>)</li>
<li>After: 1011011001‚Ä¶110<strong>1</strong>100110 (Bit at index 25 is flipped to <code>1</code>)</li>
</ul></li>
<li>Since np.random.randint(len(sol)) randomly selects a bit, every execution results in different positions being flipped.</li>
</ul>
</section>
<section id="evaluate-e" class="level3">
<h3 class="anchored" data-anchor-id="evaluate-e">Evaluate (E)</h3>
<ul>
<li>The evaluate function calculates the fitness of the current solution by summing up the number of 1‚Äôs in the binary array (sol).The One-Max problem aims to maximize this value, with the goal being to find the solution with all bits set to 1.</li>
</ul>
<div id="f1314011" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Evaluation Function (E): One-max function</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate(sol):</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.<span class="bu">sum</span>(sol)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="determination-d" class="level3">
<h3 class="anchored" data-anchor-id="determination-d">Determination (D)</h3>
<ul>
<li>The determine function decides whether to accept the new neighboring solution (neighbor_value), based on its value compared to the current solution (current_value).</li>
<li>If the neighboring solution is better (i.e., it has a higher One-Max value), it is accepted.</li>
<li>If the neighboring solution is worse, it may still be accepted based on the probability calculated by the simulated annealing algorithm:
<ul>
<li>The acceptance probability depends on the temperature and the difference between the new and current values.</li>
<li>A higher temperature allows for more exploration of worse solutions, while a lower temperature makes the algorithm more selective.</li>
</ul></li>
<li>The function returns True if the new solution is accepted, otherwise False.</li>
</ul>
<div id="5e06c7b4" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Determination function for SA (D)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> determine(neighbor_value, current_value, temperature):</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> neighbor_value <span class="op">&gt;</span> current_value:</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        acceptance_probability <span class="op">=</span> np.exp((neighbor_value <span class="op">-</span> current_value) <span class="op">/</span> temperature)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> random.random() <span class="op">&lt;</span> acceptance_probability</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Pictures/SAp_acceptance.png" title="Example of Acceptance Calculations" class="img-fluid figure-img"></p>
<figcaption>Example of Acceptance Calculations</figcaption>
</figure>
</div>
</section>
<section id="run-function" class="level3">
<h3 class="anchored" data-anchor-id="run-function">Run Function</h3>
<ul>
<li><p>The init_sa function generates a random initial solution (current_sol) with a binary array of length num_bits.</p></li>
<li><p>This solution is evaluated using the evaluate function, which counts the number of 1‚Äôs in the array.</p></li>
<li><p>The current solution is also set as the best solution initially, since no other solutions have been explored yet.</p></li>
<li><p>The temperature is set to initial_temp, which controls the probability of accepting worse solutions in the early stages of the algorithm.</p></li>
<li><p>The list value_history is initialized to store the value (fitness) of the current solution over time.</p></li>
<li><p>This main loop runs until the temperature drops below min_temp (0.0001) or the maximum number of evals (max_evals, default 1000) is reached. Each evaluation represents one step in the simulated annealing process.</p></li>
<li><p>A neighboring solution (neighbor_sol) is generated by the transit function, which randomly flips one bit in the current solution.</p></li>
<li><p>This represents exploring a new area of the search space close to the current solution.</p></li>
<li><p>The neighboring solution is evaluated using the evaluate function, which calculates its fitness (i.e., the number of 1‚Äôs in the binary array). This value is compared to the current solution‚Äôs fitness.</p></li>
<li><p>The determine function decides whether to accept the neighboring solution</p></li>
<li><p>The current solution‚Äôs fitness is appended to value_history to keep a record of the solution‚Äôs fitness across evaluations. This will later be used to plot the progress of the algorithm.</p></li>
<li><p>After each evaluation, the temperature is reduced by multiplying it by the cooling_rate (default 0.99). This cooling process gradually reduces the probability of accepting worse solutions, making the algorithm behave more like greedy hill climbing toward the end.</p></li>
<li><p>The number of evals is incremented.</p></li>
<li><p>After the loop terminates (either because the temperature has cooled sufficiently or the maximum number of evaluations has been reached), the function returns: 1) best_sol: The best solution found during the process. 2) best_value: The fitness value of the best solution. 3) value_history: A list of the fitness values over time, useful for visualizing the algorithm‚Äôs progress.</p></li>
</ul>
<div id="c81e9cd2" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulated Annealing (SA) function</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simulated_annealing(num_bits):</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    current_sol, current_value <span class="op">=</span> init_sa(num_bits)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    best_sol, best_value <span class="op">=</span> current_sol, current_value</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    temperature <span class="op">=</span> initial_temp</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    value_history <span class="op">=</span> [current_value]</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    evals <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> temperature <span class="op">&gt;</span> min_temp <span class="kw">and</span> evals <span class="op">&lt;</span> max_evals:</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        neighbor_sol <span class="op">=</span> transit(current_sol)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        neighbor_value <span class="op">=</span> evaluate(neighbor_sol)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> determine(neighbor_value, current_value, temperature):</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>            current_sol, current_value <span class="op">=</span> neighbor_sol, neighbor_value</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> current_value <span class="op">&gt;</span> best_value:</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>                best_sol, best_value <span class="op">=</span> current_sol, current_value</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Store history of values for plotting</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        value_history.append(current_value)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Cool down the temperature</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>        temperature <span class="op">*=</span> cooling_rate</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        evals <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best_sol, best_value, value_history</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Pictures/Temp.png" title="Cooling Schedule Calculations" class="img-fluid figure-img"></p>
<figcaption>Example Cooling Schedule Calculations</figcaption>
</figure>
</div>
</section>
<section id="main-execution" class="level3">
<h3 class="anchored" data-anchor-id="main-execution">Main Execution</h3>
<ul>
<li>The process starts by initializing the solution using Initialization (I) (init_sa), followed by repeated transitions (T) and evaluations (E) to explore the search space.</li>
<li>After each transition, the Determination (D) function decides whether to accept the new solution based on the current temperature and fitness values.</li>
<li>The temperature gradually cools down, reducing the chance of accepting worse solutions as the algorithm progresses.</li>
<li>Finally, the results are printed and plotted for visual analysis.</li>
</ul>
<div id="498de2b6" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Main execution</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>start_time <span class="op">=</span> time.time()</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>best_sol, best_value, value_history <span class="op">=</span> simulated_annealing(num_bits)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>end_time <span class="op">=</span> time.time()</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>execution_time <span class="op">=</span> end_time <span class="op">-</span> start_time</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="output" class="level2">
<h2 class="anchored" data-anchor-id="output">Output</h2>
<div id="24fc19da" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Output results (O)</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Best solution: </span><span class="sc">{</span>best_sol<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Best value (number of 1s): </span><span class="sc">{</span>best_value<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Execution time: </span><span class="sc">{</span>execution_time<span class="sc">:.6f}</span><span class="ss"> seconds"</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the simulated annealing progress</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>plt.plot(value_history, marker<span class="op">=</span><span class="st">'o'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, color<span class="op">=</span><span class="st">'blue'</span>, label<span class="op">=</span><span class="st">'SA Progress'</span>)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"One-Max Problem with Simulated Annealing Progress"</span>)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Iteration"</span>)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Objective Value (Number of 1s)"</span>)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Best solution: [1 1 1 1 1 1 1 1 1 1]
Best value (number of 1s): 10
Execution time: 0.008435 seconds</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="sa_files/figure-html/cell-9-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="sa-with-ackley-function" class="level1">
<h1>SA with Ackley Function</h1>
<ul>
<li><p>Temperature: The algorithm starts with a high temperature, which decreases gradually. The algorithm starts with an initial high temperature (initial_temp=10) and cools down at a rate (cooling_rate=0.99) after every iteration. The temperature affects the likelihood of accepting worse solutions.</p></li>
<li><p>Acceptance of Worse Solutions: There is a probability of accepting a worse solution, which decreases as the temperature drops. If the new (neighbor) solution is worse, it is still accepted with a probability calculated as follows: <span class="math display">\[p_a^{\text{min}} = \exp\left(\frac{\text{current\_value} - \text{neighbor\_value}}{\text{temperature}}\right)\]</span></p></li>
<li><p>This probability decreases as the temperature decreases, making it less likely to accept worse solutions later in the process.</p></li>
<li><p>Cooling Schedule: The temperature cools down over time, usually geometrically or exponentially. The temperature decreases by multiplying it by the cooling rate (0.99 in this case) at each iteration.</p></li>
</ul>
<section id="example-results" class="level2">
<h2 class="anchored" data-anchor-id="example-results">Example Results</h2>
<div id="5c454052" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the necessary global variables</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>num_evals <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>initial_temp <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>cooling_rate <span class="op">=</span> <span class="fl">0.99</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>min_temp <span class="op">=</span> <span class="fl">0.00001</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Ackley function (1D)</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ackley(x):</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> np.pi</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    term1 <span class="op">=</span> <span class="op">-</span>a <span class="op">*</span> np.exp(<span class="op">-</span>b <span class="op">*</span> np.sqrt(np.mean(np.square(x))))</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    term2 <span class="op">=</span> <span class="op">-</span>np.exp(np.mean(np.cos(c <span class="op">*</span> np.array(x))))</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> term1 <span class="op">+</span> term2 <span class="op">+</span> a <span class="op">+</span> np.exp(<span class="dv">1</span>)</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialization function (I) to set the starting point</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> init_sa():</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    start_x <span class="op">=</span> random.uniform(<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>)</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> start_x, ackley([start_x])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li>Here, the new candidate solution (neighbor_x) is generated by adding a random perturbation from the uniform distribution random.uniform(-1, 1). This means the step size varies randomly between -1 and 1.</li>
<li>If you want more control over the step size, you could introduce a parameter, step_size, and modify the function.</li>
</ul>
<div id="62b30c99" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Transition function (T)</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> transit(current_x):</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    neighbor_x <span class="op">=</span> current_x <span class="op">+</span> random.uniform(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> neighbor_x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li>The determine function is the same as the One Max problem except that because the Ackley is a min problem the neighbor_value and current_value switch places.</li>
</ul>
<div id="dc197cb4" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Determination function for SA (D)</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> determine(neighbor_value, current_value, temperature):</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> neighbor_value <span class="op">&lt;</span> current_value:</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        acceptance_probability <span class="op">=</span> np.exp((current_value <span class="op">-</span> neighbor_value) <span class="op">/</span> temperature)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.random.rand() <span class="op">&lt;</span> acceptance_probability</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="902163b6" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulated Annealing (SA) function</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simulated_annealing():</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>     <span class="co">#Initialize (I)</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    current_x, current_value <span class="op">=</span> init_sa()</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    best_x, best_value <span class="op">=</span> current_x, current_value</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    temperature <span class="op">=</span> initial_temp</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    x_history, value_history <span class="op">=</span> [current_x], [current_value]</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    evals <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>   <span class="co">#Transit (T) </span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> temperature <span class="op">&gt;</span> min_temp <span class="kw">and</span> evals <span class="op">&lt;</span> max_evals:</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>        neighbor_x <span class="op">=</span> transit(current_x)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Evaluate (E)</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>        neighbor_value <span class="op">=</span> ackley([neighbor_x])</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Determine (D)</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> determine(neighbor_value, current_value, temperature):</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>            current_x, current_value <span class="op">=</span> neighbor_x, neighbor_value</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> current_value <span class="op">&lt;</span> best_value:</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>                best_x, best_value <span class="op">=</span> current_x, current_value</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Store history of x and values for plotting</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>        x_history.append(current_x)</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>        value_history.append(current_value)</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Cool down the temperature</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>        temperature <span class="op">*=</span> cooling_rate</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>        evals <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best_x, best_value, x_history, value_history</span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Main execution</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>start_time <span class="op">=</span> time.time()</span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>best_x, best_value, x_history, value_history <span class="op">=</span> simulated_annealing()</span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>end_time <span class="op">=</span> time.time()</span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>execution_time <span class="op">=</span> end_time <span class="op">-</span> start_time</span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Output (O)</span></span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Optimal x: </span><span class="sc">{</span>best_x<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Optimal value: </span><span class="sc">{</span>best_value<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Execution time: </span><span class="sc">{</span>execution_time<span class="sc">:.6f}</span><span class="ss"> seconds"</span>)</span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the Ackley function and simulated annealing progress</span></span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a>x_values <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">1000</span>)</span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a>y_values <span class="op">=</span> [ackley([x]) <span class="cf">for</span> x <span class="kw">in</span> x_values]</span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a>plt.plot(x_values, y_values, label<span class="op">=</span><span class="st">"Ackley Function"</span>, color<span class="op">=</span><span class="st">'b'</span>)</span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a>plt.plot(x_history, value_history, marker<span class="op">=</span><span class="st">'o'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, color<span class="op">=</span><span class="st">'red'</span>, label<span class="op">=</span><span class="st">'SA Progress'</span>)</span>
<span id="cb13-50"><a href="#cb13-50" aria-hidden="true" tabindex="-1"></a>plt.scatter(best_x, best_value, color<span class="op">=</span><span class="st">'green'</span>, s<span class="op">=</span><span class="dv">100</span>, zorder<span class="op">=</span><span class="dv">5</span>, label<span class="op">=</span><span class="st">'Optimal Value'</span>)</span>
<span id="cb13-51"><a href="#cb13-51" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Ackley Function in 1D with Simulated Annealing Progress"</span>)</span>
<span id="cb13-52"><a href="#cb13-52" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"x"</span>)</span>
<span id="cb13-53"><a href="#cb13-53" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"f(x)"</span>)</span>
<span id="cb13-54"><a href="#cb13-54" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb13-55"><a href="#cb13-55" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb13-56"><a href="#cb13-56" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Optimal x: 0.0021100516227827715
Optimal value: 0.00867730864647287
Execution time: 0.011569 seconds</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="sa_files/figure-html/cell-13-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<ul>
<li>Optimal x: -0.0006396808092359318
<ul>
<li>The value -0.00063968 represents a point very close to 0 on the x-axis, where the Ackley function achieves its minimum value in the 1D case.The true global minimum of the Ackley function occurs at x=0, so this value is nearly optimal.</li>
</ul></li>
<li>Optimal value: 0.0025805153299995887
<ul>
<li>The Ackley function‚Äôs global minimum is 0, which occurs exactly at x=0. The value 0.0025805153299995887 is very close to this, showing that the algorithm successfully minimized the function but did not reach the exact minimum. This small difference can be due to the stochastic nature of simulated annealing and the stopping criteria (temperature and iterations).</li>
</ul></li>
<li>Execution time: 0.012161 seconds
<ul>
<li>This indicates the total time it took for the simulated annealing algorithm to run and find the optimal solution.</li>
<li>The process completed in just 0.012 seconds, which is very fast. This fast execution time suggests that the algorithm quickly converged to a near-optimal solution, likely because the problem space (1D) is simple and small, and the Ackley function‚Äôs shape guides the algorithm efficiently toward the global minimum.</li>
</ul></li>
</ul>
<section id="comparing-sa-to-hc-with-ackley-function" class="level3">
<h3 class="anchored" data-anchor-id="comparing-sa-to-hc-with-ackley-function">Comparing SA to HC with Ackley Function</h3>
<ul>
<li>In an example run, I found the following results depicted in the png image below. The simulated annealing algorithm performed well, finding a solution very close to the global minimum of the Ackley function in a short time.</li>
<li>The slight deviation from the exact minimum value (0) is expected due to the stochastic exploration nature of simulated annealing. You can compare these results to the ones above under a different set seed.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Pictures/sa4.png" title="UFM" class="img-fluid figure-img"></p>
<figcaption>Comparing HA with Ackley</figcaption>
</figure>
</div>
<ul>
<li>Our SA model was much better than our HC model with the Ackley Function. Why?
<ul>
<li>The Ackley function is known for its multimodal landscape‚Äîit has many local minima and a global minimum at ùë•=0. The landscape consists of a broad plateau followed by sharp drops toward the global minimum, making it challenging for optimization algorithms to find the true global minimum.</li>
<li>Hill climbing can get stuck in one of the many local minima because it only moves to a better neighboring solution. Once it reaches a local minimum, it can‚Äôt escape because no better solution is immediately available in its neighborhood.</li>
<li>Simulated annealing, by contrast, has the ability to accept worse solutions early in the process, which allows it to escape local minima and continue searching for the global minimum.</li>
</ul></li>
</ul>
</section>
</section>
</section>
<section id="portfolio-diversification-with-sa" class="level1">
<h1>Portfolio Diversification With SA</h1>
<div id="5c278194" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Simulated Annealing Finance Example</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> yfinance <span class="im">as</span> yf</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the necessary global variables</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>max_evals <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>initial_temp <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>cooling_rate <span class="op">=</span> <span class="fl">0.99</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>min_temp <span class="op">=</span> <span class="fl">.0001</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="co"># List of stocks and historical data</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>stocks <span class="op">=</span> [<span class="st">'AAPL'</span>, <span class="st">'GOOGL'</span>, <span class="st">'MSFT'</span>, <span class="st">'AMZN'</span>, <span class="st">'TSLA'</span>, <span class="st">'NFLX'</span>, <span class="st">'NVDA'</span>, <span class="st">'META'</span>, <span class="st">'DIS'</span>, <span class="st">'BA'</span>]</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>start_date <span class="op">=</span> <span class="st">'2023-12-01'</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>end_date <span class="op">=</span> <span class="st">'2025-12-01'</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Fetch historical stock data</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fetch_data(stocks, start_date, end_date):</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> yf.download(stocks, start<span class="op">=</span>start_date, end<span class="op">=</span>end_date, auto_adjust<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>stock_data <span class="op">=</span> fetch_data(stocks, start_date, end_date)</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Evaluation Function (E): Portfolio performance calculation</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> portfolio_performance(weights, mean_returns, cov_matrix):</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>    returns <span class="op">=</span> np.<span class="bu">sum</span>(mean_returns <span class="op">*</span> weights) <span class="op">*</span> <span class="dv">252</span>  <span class="co"># Annualized returns</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>    risk <span class="op">=</span> np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights))) <span class="op">*</span> np.sqrt(<span class="dv">252</span>)  <span class="co"># Annualized risk</span></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>    sharpe_ratio <span class="op">=</span> returns <span class="op">/</span> risk  <span class="co"># Sharpe ratio</span></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> returns, risk, sharpe_ratio</span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialization function (I)</span></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> initialize_portfolio(stocks):</span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>    weights <span class="op">=</span> np.random.random(<span class="bu">len</span>(stocks))</span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>    weights <span class="op">/=</span> np.<span class="bu">sum</span>(weights)  <span class="co"># Ensure weights sum to 1</span></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> weights</span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Transition function (T)</span></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> transition_portfolio(weights):</span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a>    new_weights <span class="op">=</span> weights.copy()</span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a>    index <span class="op">=</span> np.random.randint(<span class="bu">len</span>(weights))</span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>    new_weights[index] <span class="op">=</span> np.random.uniform(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a>    new_weights <span class="op">/=</span> np.<span class="bu">sum</span>(new_weights)  </span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> new_weights</span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-46"><a href="#cb15-46" aria-hidden="true" tabindex="-1"></a><span class="co"># Determination function (D)</span></span>
<span id="cb15-47"><a href="#cb15-47" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> determine_portfolio(neighbor_sharpe, current_sharpe, temperature):</span>
<span id="cb15-48"><a href="#cb15-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> neighbor_sharpe <span class="op">&gt;</span> current_sharpe:</span>
<span id="cb15-49"><a href="#cb15-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb15-50"><a href="#cb15-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb15-51"><a href="#cb15-51" aria-hidden="true" tabindex="-1"></a>        acceptance_probability <span class="op">=</span> np.exp((neighbor_sharpe <span class="op">-</span> current_sharpe) <span class="op">/</span> temperature)</span>
<span id="cb15-52"><a href="#cb15-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.random.rand() <span class="op">&lt;</span> acceptance_probability</span>
<span id="cb15-53"><a href="#cb15-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-54"><a href="#cb15-54" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulated Annealing (SA) function</span></span>
<span id="cb15-55"><a href="#cb15-55" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simulated_annealing(stocks, mean_returns, cov_matrix, max_evals, initial_temp, cooling_rate):</span>
<span id="cb15-56"><a href="#cb15-56" aria-hidden="true" tabindex="-1"></a>    current_weights <span class="op">=</span> initialize_portfolio(stocks)</span>
<span id="cb15-57"><a href="#cb15-57" aria-hidden="true" tabindex="-1"></a>    _, _, current_sharpe <span class="op">=</span> portfolio_performance(current_weights, mean_returns, cov_matrix)</span>
<span id="cb15-58"><a href="#cb15-58" aria-hidden="true" tabindex="-1"></a>    best_weights, best_sharpe <span class="op">=</span> current_weights, current_sharpe</span>
<span id="cb15-59"><a href="#cb15-59" aria-hidden="true" tabindex="-1"></a>    temperature <span class="op">=</span> initial_temp</span>
<span id="cb15-60"><a href="#cb15-60" aria-hidden="true" tabindex="-1"></a>    sharpe_history <span class="op">=</span> [current_sharpe]</span>
<span id="cb15-61"><a href="#cb15-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-62"><a href="#cb15-62" aria-hidden="true" tabindex="-1"></a>    evals <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb15-63"><a href="#cb15-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> temperature <span class="op">&gt;</span> min_temp <span class="kw">and</span> evals <span class="op">&lt;</span> max_evals:</span>
<span id="cb15-64"><a href="#cb15-64" aria-hidden="true" tabindex="-1"></a>        neighbor_weights <span class="op">=</span> transition_portfolio(current_weights)</span>
<span id="cb15-65"><a href="#cb15-65" aria-hidden="true" tabindex="-1"></a>        _, _, neighbor_sharpe <span class="op">=</span> portfolio_performance(neighbor_weights, mean_returns, cov_matrix)</span>
<span id="cb15-66"><a href="#cb15-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-67"><a href="#cb15-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> determine_portfolio(neighbor_sharpe, current_sharpe, temperature):</span>
<span id="cb15-68"><a href="#cb15-68" aria-hidden="true" tabindex="-1"></a>            current_weights, current_sharpe <span class="op">=</span> neighbor_weights, neighbor_sharpe</span>
<span id="cb15-69"><a href="#cb15-69" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> neighbor_sharpe <span class="op">&gt;</span> best_sharpe:</span>
<span id="cb15-70"><a href="#cb15-70" aria-hidden="true" tabindex="-1"></a>                best_weights, best_sharpe <span class="op">=</span> neighbor_weights, neighbor_sharpe</span>
<span id="cb15-71"><a href="#cb15-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-72"><a href="#cb15-72" aria-hidden="true" tabindex="-1"></a>        sharpe_history.append(current_sharpe)</span>
<span id="cb15-73"><a href="#cb15-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-74"><a href="#cb15-74" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Cool down the temperature</span></span>
<span id="cb15-75"><a href="#cb15-75" aria-hidden="true" tabindex="-1"></a>        temperature <span class="op">*=</span> cooling_rate</span>
<span id="cb15-76"><a href="#cb15-76" aria-hidden="true" tabindex="-1"></a>        evals <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb15-77"><a href="#cb15-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-78"><a href="#cb15-78" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best_weights, best_sharpe, sharpe_history</span>
<span id="cb15-79"><a href="#cb15-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-80"><a href="#cb15-80" aria-hidden="true" tabindex="-1"></a>returns <span class="op">=</span> stock_data[<span class="st">'Close'</span>].pct_change().dropna()</span>
<span id="cb15-81"><a href="#cb15-81" aria-hidden="true" tabindex="-1"></a>mean_returns <span class="op">=</span> returns.mean()</span>
<span id="cb15-82"><a href="#cb15-82" aria-hidden="true" tabindex="-1"></a>cov_matrix <span class="op">=</span> returns.cov()</span>
<span id="cb15-83"><a href="#cb15-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-84"><a href="#cb15-84" aria-hidden="true" tabindex="-1"></a><span class="co"># Run simulated annealing for portfolio optimization</span></span>
<span id="cb15-85"><a href="#cb15-85" aria-hidden="true" tabindex="-1"></a>start_time <span class="op">=</span> time.time()</span>
<span id="cb15-86"><a href="#cb15-86" aria-hidden="true" tabindex="-1"></a>best_weights, best_sharpe, sharpe_history <span class="op">=</span> simulated_annealing(stocks, mean_returns, cov_matrix, max_evals, initial_temp, cooling_rate)</span>
<span id="cb15-87"><a href="#cb15-87" aria-hidden="true" tabindex="-1"></a>end_time <span class="op">=</span> time.time()</span>
<span id="cb15-88"><a href="#cb15-88" aria-hidden="true" tabindex="-1"></a>execution_time <span class="op">=</span> end_time <span class="op">-</span> start_time</span>
<span id="cb15-89"><a href="#cb15-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-90"><a href="#cb15-90" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the progress of the simulated annealing algorithm</span></span>
<span id="cb15-91"><a href="#cb15-91" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb15-92"><a href="#cb15-92" aria-hidden="true" tabindex="-1"></a>plt.plot(sharpe_history, marker<span class="op">=</span><span class="st">'o'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, color<span class="op">=</span><span class="st">'b'</span>, label<span class="op">=</span><span class="st">'Sharpe Ratio Progress'</span>)</span>
<span id="cb15-93"><a href="#cb15-93" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Simulated Annealing Progress for Portfolio Optimization (Sharpe Ratio)"</span>)</span>
<span id="cb15-94"><a href="#cb15-94" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Iteration"</span>)</span>
<span id="cb15-95"><a href="#cb15-95" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Sharpe Ratio"</span>)</span>
<span id="cb15-96"><a href="#cb15-96" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb15-97"><a href="#cb15-97" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb15-98"><a href="#cb15-98" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb15-99"><a href="#cb15-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-100"><a href="#cb15-100" aria-hidden="true" tabindex="-1"></a><span class="co"># Display the results</span></span>
<span id="cb15-101"><a href="#cb15-101" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Optimized Portfolio:"</span>)</span>
<span id="cb15-102"><a href="#cb15-102" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, stock <span class="kw">in</span> <span class="bu">enumerate</span>(stocks):</span>
<span id="cb15-103"><a href="#cb15-103" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>stock<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>best_weights[i]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb15-104"><a href="#cb15-104" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Best Sharpe Ratio: </span><span class="sc">{</span>best_sharpe<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb15-105"><a href="#cb15-105" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Execution time: </span><span class="sc">{</span>execution_time<span class="sc">:.6f}</span><span class="ss"> seconds"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>[                       0%                       ][**********            20%                       ]  2 of 10 completed[**************        30%                       ]  3 of 10 completed[*******************   40%                       ]  4 of 10 completed[*******************   40%                       ]  4 of 10 completed[**********************60%****                   ]  6 of 10 completed[**********************70%*********              ]  7 of 10 completed[**********************80%*************          ]  8 of 10 completed[**********************90%******************     ]  9 of 10 completed[*********************100%***********************]  10 of 10 completed</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="sa_files/figure-html/cell-14-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Optimized Portfolio:
AAPL: 0.0095
GOOGL: 0.0002
MSFT: 0.0000
AMZN: 0.0060
TSLA: 0.4316
NFLX: 0.0024
NVDA: 0.0001
META: 0.3275
DIS: 0.2201
BA: 0.0027
Best Sharpe Ratio: 2.0606
Execution time: 0.068354 seconds</code></pre>
</div>
</div>
<section id="which-model-is-better" class="level2">
<h2 class="anchored" data-anchor-id="which-model-is-better">Which Model is Better</h2>
<ul>
<li>Hill Climbing
<ul>
<li>Deterministic: In each iteration, the algorithm strictly accepts a new portfolio only if it improves the Sharpe ratio (a measure of risk-adjusted returns). There‚Äôs no acceptance of worse solutions.</li>
<li>This results in a steady and consistent increase in the Sharpe ratio because the model always moves toward better solutions without exploring worse ones.</li>
<li>Since hill climbing is greedy and deterministic, it focuses on continuously improving the portfolio weights in a direct manner, which can be more efficient for problems where the optimization landscape is relatively smooth or doesn‚Äôt have too many local minima.</li>
</ul></li>
<li>Simulated Annealing:
<ul>
<li>Stochastic Exploration: Simulated annealing, on the other hand, allows for the acceptance of worse solutions, especially early in the process when the temperature is high. This stochastic exploration helps to avoid getting stuck in local minima, but it can sometimes lead to suboptimal moves that temporarily reduce performance.</li>
<li>SA slowly improves the Sharpe ratio by lowering the temperature and becoming more selective over time. However, this can result in slower convergence compared to hill climbing, which directly improves the Sharpe ratio with each iteration.</li>
<li>While simulated annealing balances exploration and exploitation, its performance might be slightly worse in this case because it explores a broader range of solutions, some of which may be worse. The stochastic nature may cause delays in reaching the global optimum in cases where the optimization problem is less prone to getting stuck in local minima.</li>
</ul></li>
</ul>
</section>
</section>
<section id="using-ai" class="level1">
<h1>Using AI</h1>
<ul>
<li>Use the following prompt on a generative AI, like chatGPT, to learn more about the topics covered.</li>
<li>Metaheuristics Overview: What is a metaheuristic algorithm, and how does it differ from other optimization approaches like exhaustive search and hill climbing? Provide an example of a real-world problem suitable for metaheuristic algorithms.</li>
<li>Simulated Annealing Basics: Explain the key components of simulated annealing, including its transition, evaluation, and determination steps. Why is temperature an essential factor in the algorithm?</li>
<li>Exploration vs.&nbsp;Exploitation: Discuss how simulated annealing balances exploration and exploitation during the optimization process. How does this compare to greedy and hill climbing algorithms?</li>
<li>Parameter Tuning: Why is tuning parameters like cooling schedule and neighborhood size crucial in simulated annealing? Suggest strategies for finding optimal parameter values.</li>
<li>Fitness Evolution: How does the cooling rate affect the trajectory of fitness improvement in a simulated annealing for the One-Max problem?</li>
<li>Solution Space Exploration: Discuss how the simulated annealing algorithm explores the rugged landscape of an Ackley Function and converges to a solution.</li>
<li>Industry Use Cases: Discuss real-world applications of simulated annealing in fields such as machine learning, logistics, and engineering. Why is SA particularly suited for these problems?</li>
<li>Challenges in SA: Reflect on the challenges of applying simulated annealing to real-world problems. How do computational cost and parameter sensitivity influence its practicality?</li>
<li>Algorithm Design: How does understanding the strengths and limitations of simulated annealing inform the design of new metaheuristic algorithms?</li>
</ul>
<section id="conclusions" class="level2">
<h2 class="anchored" data-anchor-id="conclusions">Conclusions</h2>
<ul>
<li>Stable and Simple Search Space: In portfolio optimization, especially with a limited number of assets, the optimization landscape might not be highly rugged, making hill climbing‚Äôs greedy approach more effective at converging quickly to a good solution.</li>
<li>Direct Progress: Hill climbing consistently increases the Sharpe ratio by only accepting better solutions, leading to slightly higher risk-adjusted returns over the SA model, which accepts suboptimal solutions early on.</li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./hc.html" class="pagination-link" aria-label="Hill Climbing">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-title">Hill Climbing</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./ga.html" class="pagination-link" aria-label="Genetic Algorithms">
        <span class="nav-page-text"><span class="chapter-title">Genetic Algorithms</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>