{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Exhaustive Search\"\n",
        "author: \"Pamela Schlosser\"\n",
        "format: html\n",
        "runtime: python\n",
        "---\n",
        "\n",
        "\n",
        "-   If you had unlimited time to search through every possible hobby in the world, which one do you think you’d end up pursuing?\n",
        "\n",
        "-   Exhaustive Search (also known as brute-force search) is a problem-solving technique that systematically enumerates all possible solutions to find the best one.\n",
        "\n",
        "-   It evaluates every potential solution against the objective function and selects the optimal one.\n",
        "\n",
        "-   When to use: When the problem size is small and when optimality is critical and computation time is feasible.\n",
        "\n",
        "-   Limitations: Computationally expensive. Not feasible for large problem spaces due to exponential time complexity.\n",
        "\n",
        "## Advantages and Disadvantages of ES\n",
        "\n",
        "-   Advantages:\n",
        "    -   Guaranteed Optimal Solution: Finds the best possible solution, ensuring optimality.\n",
        "    -   Simplicity: Easy to understand and implement for small-scale problems.\n",
        "-   Disadvantages:\n",
        "    -   Scalability Issues: Infeasible for large datasets due to exponential time complexity.\n",
        "    -   Resource Intensive: High computational cost in terms of time and memory.\n",
        "\n",
        "### Exhaustive Search Algorithm\n",
        "\n",
        "-   Check all the candidate solutions in the solution space of the problem in question; therefore, it is always capable of finding the best solution for the problem in question.\n",
        "\n",
        "![es algorithm](Pictures/es.png \"Exhaustive Search Algorithm\")\n",
        "\n",
        "## Exhaustive Search in Continuous vs. Discrete Domains\n",
        "\n",
        "\n",
        "-   Discrete Domains: Solutions can be explicitly enumerated without discretization.\n",
        "    -   Example: Knapsack problem.\n",
        "\n",
        "-   Continuous Domains: Require discretization (using a step size) to make exhaustive search feasible.\n",
        "    -   Example: Ackley function.\n",
        "\n",
        "-   Challenges in Continuous Domains:\n",
        "    -   Infinite solution space makes direct enumeration impossible.\n",
        "    -   Step size is critical for balancing resolution and computational cost.\n",
        "\n",
        "* Note that Discretization is the process of converting continuous data or variables into discrete categories or bins.\n",
        "\n",
        "### Role of Step Size in Continuous Optimization\n",
        "\n",
        "* Step size in exhaustive search is the distance between consecutive sample points in the search space. A small step size results in a finer grid with higher precision but increases computation time, while a larger step size reduces computation time but may miss optimal solutions.\n",
        "\n",
        "-   Why Step Size Matters: Controls the granularity of the search.\n",
        "    -   Smaller steps increase resolution but significantly raise computation time.\n",
        "    -   Larger steps reduce computational cost but risk missing the optimal solution.\n",
        "-   Practical Considerations:\n",
        "    -   Optimal step size depends on the problem's scale and the required precision.\n",
        "    -   Trade-off between efficiency and accuracy.\n",
        "-   When is Exhaustive Search Practical?\n",
        "    -   Discrete Domains:\n",
        "        -   Feasible if the solution space is small (manageable number of combinations).\n",
        "        -   Guarantees finding the exact optimal solution.\n",
        "    -   Continuous Domains:\n",
        "        -   Only practical when the domain is small and can be discretized effectively.\n",
        "    -   Higher dimensions increase complexity exponentially (curse of dimensionality).\n",
        "\n",
        "## The Search Strategy of ES\n"
      ],
      "id": "671a628e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "import matplotlib.pyplot as plt\n",
        "import numpy as np\n",
        "\n",
        "# Defining data to replicate the chart\n",
        "# Binary labels for solution space\n",
        "labels = [\n",
        "    \"(0000)\", \"(0001)\", \"(0010)\", \"(0011)\", \"(0100)\", \"(0101)\", \"(0110)\", \"(0111)\",\n",
        "    \"(1000)\", \"(1001)\", \"(1010)\", \"(1011)\", \"(1100)\", \"(1101)\", \"(1110)\", \"(1111)\"\n",
        "]\n",
        "objective_values = [0, 1, 1.5, 2.5, 1, 1.5, 2, 1.5, 0.5, 1.5, 1.5, 3, 1, 1.5, 2, 4]\n",
        "\n",
        "# X-axis positions for the labels\n",
        "x = np.arange(len(labels))\n",
        "\n",
        "# Create the figure and two subplots for the two parts of the chart\n",
        "fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 4), gridspec_kw={'height_ratios': [3, 1]})\n",
        "\n",
        "# Plotting the objective value vs solution space\n",
        "ax1.plot(x, objective_values, color='black', marker='o', markersize=10, linestyle='-', linewidth=1)\n",
        "\n",
        "# Highlight specific points\n",
        "for i, value in enumerate(objective_values):\n",
        "    if i == 0:\n",
        "        color = 'white'  # Start point (S)\n",
        "    elif i == len(objective_values) - 1:\n",
        "        color = 'red'    # End point (E)\n",
        "    elif value >= 2.5:\n",
        "        color = 'black'  # High objective points\n",
        "    else:\n",
        "        color = 'lightpink'  # Other points\n",
        "    ax1.plot(x[i], objective_values[i], marker='o', markersize=10, color=color, markeredgecolor='black')\n",
        "\n",
        "# Setting labels and limits for the objective plot\n",
        "ax1.set_ylabel(\"Objective Value\")\n",
        "ax1.set_xticks(x)\n",
        "ax1.set_xticklabels(labels, rotation=45)\n",
        "ax1.set_ylim(0, 5)\n",
        "\n",
        "# Solution space line plot\n",
        "ax2.plot(x, [0]*len(x), color='black', marker='o', markersize=10, linestyle='-')\n",
        "\n",
        "# Marking specific points in the solution space\n",
        "for i in range(len(x)):\n",
        "    if i == 0:\n",
        "        color = 'white'  # Start point (S)\n",
        "    elif i == len(objective_values) - 1:\n",
        "        color = 'red'    # End point (E)\n",
        "    elif objective_values[i] >= 2.5:\n",
        "        color = 'black'  # High objective points\n",
        "    else:\n",
        "        color = 'lightpink'  # Other points\n",
        "    ax2.plot(x[i], 0, marker='o', markersize=10, color=color, markeredgecolor='black')\n",
        "\n",
        "# Add start (S) and end (E) labels\n",
        "ax2.text(-0.5, 0, 'S', ha='center', va='center', fontsize=12, color='black')\n",
        "ax2.text(len(x) - 0.5, 0, 'E', ha='center', va='center', fontsize=12, color='black')\n",
        "\n",
        "# Customizing the solution space plot\n",
        "ax2.set_yticks([])\n",
        "ax2.set_xticks(x)\n",
        "ax2.set_xticklabels(labels, rotation=45)\n",
        "ax2.set_xlabel(\"Solution Space\")\n",
        "\n",
        "# Adjust layout and show plot\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "8b6cf020",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Knapsack Problem Example of ES\n",
        "\n",
        "-   Finding Optimal Subset of Items to Max Value in Knapsack Problem using Exhaustive Search\n"
      ],
      "id": "76f2373e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from itertools import combinations\n",
        "\n",
        "# Define the items and maximum weight\n",
        "items = {\n",
        "    \"Item 1\": {\"weight\": 3, \"value\": 4},\n",
        "    \"Item 2\": {\"weight\": 4, \"value\": 5},\n",
        "    \"Item 3\": {\"weight\": 7, \"value\": 10}\n",
        "}\n",
        "max_weight = 10\n",
        "\n",
        "# Exhaustive search function \n",
        "def knapsack_exhaustive_while(items, max_weight):\n",
        "    best_value = 0\n",
        "    best_combination = []\n",
        "\n",
        "    item_names = list(items.keys())  # Extract item names for combinations\n",
        "\n",
        "    r = 1\n",
        "    while r <= len(items):  # Iterating over different combination sizes\n",
        "        combos = list(combinations(item_names, r))  # Generate combinations using keys\n",
        "        i = 0\n",
        "        while i < len(combos):  # Iterating over each combination\n",
        "            combo = combos[i]\n",
        "            weight = sum(items[item]['weight'] for item in combo)\n",
        "            value = sum(items[item]['value'] for item in combo)\n",
        "\n",
        "            if weight <= max_weight and value > best_value:\n",
        "                best_value = value\n",
        "                best_combination = combo \n",
        "\n",
        "            i += 1  # Moving to the next combination\n",
        "        r += 1  # Increasing the size of combinations to check\n",
        "\n",
        "    return best_value, best_combination\n",
        "\n",
        "# Run the exhaustive search knapsack algorithm\n",
        "best_value, best_combination = knapsack_exhaustive_while(items, max_weight)\n",
        "\n",
        "# Print results (O)\n",
        "print(f\"Optimal items selected: {', '.join(best_combination)} | \"\n",
        "      f\"Total Weight: {sum(items[item]['weight'] for item in best_combination)} | \"\n",
        "      f\"Total Value: {best_value}\")\n"
      ],
      "id": "dfaa1699",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   Step 1: Calculate Ratios\n",
        "    -   $wv1 = 4/3 = 1.333$\n",
        "    -   $wv2 = 5/4 = 1.25$\n",
        "    -   $wv3 = 10/7 = 1.428571$\n",
        "-   Step 2: Order by Ratio (High to Low)\n",
        "    -   $wv3$ at $1.43$\n",
        "    -   $wv1$ at $1.333$\n",
        "    -   $wv2$ at $1.25$\n",
        "-   Step 3: Fill the Sack\n",
        "    -   Add {7:10 and then 3:4} filled to 10 weight\n",
        "    -   Optimal items: ({'weight': 3, 'value': 4}, {'weight': 7, 'value': 10}), Total Value: 14\n",
        "\n",
        "# ES with a One Max Problem\n",
        "\n",
        "## Algorithmic Steps of ES\n",
        "\n",
        "-   For each binary solution (up to num_bits length), the code evaluates the number of 1's in its binary representation (which is used as the \"fitness\" value).\n",
        "\n",
        "-   It then finds the solution with the highest number of 1's (the one with the most bits set to 1).\n",
        "\n",
        "-   Import necessary tools: time for timing and matplotlib for plotting results.\n",
        "\n",
        "-   Set up run function\n",
        "\n",
        "    -   Loop through all possible solutions.\n",
        "    -   Evaluate each one and track its fitness.\n",
        "    -   Update the best solution as needed.\n",
        "    -   Return the best solution and fitness progress.\n",
        "\n",
        "-   Define helper functions:\n",
        "\n",
        "    -   Transit: Move to the next solution.\n",
        "    -   Evaluate: Count the number of 1s in the binary version of the solution (higher is better).\n",
        "    -   Determine: Compare fitness in order to track the best solution found so far.\n",
        "\n",
        "## Imports\n"
      ],
      "id": "3679f58e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import time\n",
        "import matplotlib.pyplot as plt"
      ],
      "id": "a130ddc9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## run_exhaustive_search function\n",
        "\n",
        "-   run_exhaustive_search(num_bits):\n",
        "-   Calculates the total number of possible solutions max_sol is the maximum possible solution, which is $2^{numbits}$. $2 ** numbits$: This correctly represents the total number of possible combinations when you have numbits binary bits. For example, if numbits = 3, the possible solutions range from $000 (0)$ to $111 (7)$, resulting in $2^3=8$ solutions.\n",
        "-   Initializes $s$ is the current solution, initially set to 0.\n",
        "-   Initializes $best_fitness$ and $best_solution$ to track the best results.\n",
        "-   Initializes an empty list $fitness_over_time$ to track the fitness at each step.\n"
      ],
      "id": "87615ef8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Function for initialization (I)\n",
        "def init_es(num_bits=10):\n",
        "    max_sol = 2 ** num_bits  # Total number of solutions\n",
        "    s = 0  # Step 1: Set the initial solution s = (0)\n",
        "    f_s = evaluate(s)  # Step 2: Evaluate initial solution\n",
        "    return s, f_s, max_sol"
      ],
      "id": "4f8a3317",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Helper Functions\n",
        "\n",
        "-   transit(s): Simply increments the current solution by 1.\n"
      ],
      "id": "243b8692"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Function for transit (T)\n",
        "def transit(s):\n",
        "    s += 1\n",
        "    return s"
      ],
      "id": "55b2af85",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   evaluate(s): Evaluates the \"fitness\" of the solution by counting how many 1's are present in its binary representation. The more 1's, the better the solution.\n"
      ],
      "id": "19b74ae6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Function for evaluation (E)\n",
        "def evaluate(s):\n",
        "    return bin(s).count(\"1\")  # Counts the number of 1s in the binary representation of s"
      ],
      "id": "034f2edd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   determine(fv, v, fs, s): This method checks whether the fitness of the new solution (fv) is greater than the current best fitness (fs). If so, it updates the current best solution and fitness.\n"
      ],
      "id": "84608ccd"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Function for determine (D)\n",
        "def determine(fv, v, fs, s):\n",
        "    if fv > fs:\n",
        "        fs, s = fv, v\n",
        "    return fs, s"
      ],
      "id": "4c07e988",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Main Loop\n",
        "\n",
        "-   A while loop iterates through all possible solutions (represented by s). For each solution s, it calculates the fitness using the evaluate() function.\n",
        "     + For each iteration, the solution is updated (transit method), evaluated (evaluate method), and the best solution is determined (determine method).\n",
        "     + The loop continues until all possible solutions (v from 0 to max_sol) have been evaluated.\n",
        "* fitness is the \"fitness\" score of the current solution, calculated using evaluate(s) (which counts the number of 1's in the binary representation of s).\n",
        "* Appends the fitness value to fitness_over_time.\n",
        "* determine() updates fs (fitness) and s (solution) if the new solution (v) has a higher fitness.\n",
        "* If the current solution has a better fitness than the best found so far, it updates the best fitness and solution.\n",
        "\n",
        "* Return Values: Returns fitness_over_time and best_solution after completing the exhaustive search.\n"
      ],
      "id": "ad49dd31"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Run function for exhaustive search\n",
        "def run_exhaustive_search(num_bits=10):\n",
        "    # Initialize using init_es\n",
        "    s, f_s, max_sol = init_es(num_bits)\n",
        "    \n",
        "    #Set v = s\n",
        "    best_solution = s\n",
        "    best_fitness = f_s\n",
        "    \n",
        "    fitness_over_time = []\n",
        "    \n",
        "    # While the termination criterion is not met\n",
        "    while s < max_sol:\n",
        "        # Generate the next solution v = GenNext(v)\n",
        "        v = s\n",
        "        \n",
        "        # Evaluate the new solution\n",
        "        f_v = evaluate(v)\n",
        "        \n",
        "        # Track fitness over time for plotting\n",
        "        fitness_over_time.append(f_v)\n",
        "        \n",
        "        # Print current solution and its fitness: Print command commented out for simplicity because it prints all the comparisons. \n",
        "        #print(f\"{f_v} # {v:0{num_bits}b}\")\n",
        "        \n",
        "        #If f_v is better than f_s, update s = v, f_s = f_v\n",
        "        best_fitness, best_solution = determine(f_v, v, best_fitness, best_solution)\n",
        "\n",
        "        #continued: Move to the next solution\n",
        "        s += 1  # Increment solution\n",
        "    \n",
        "    #Returned for Output the best solution\n",
        "    return fitness_over_time, best_solution"
      ],
      "id": "6470ada8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Main Execution\n",
        "\n",
        "-   In exhaustive search, the \"main execution\" often focuses on setting the number of bits because exhaustive search involves systematically evaluating all possible solutions in the search space. When the solutions are represented as binary strings, the number of bits directly determines the size of the search space.\n",
        "-   Why it matters:\n",
        "    -   Defining the Search Space: The number of bits defines how many unique binary strings (or configurations) are possible. For $2^n$ possible combinations. So, by setting the number of bits, you are effectively defining the boundaries of the search space.\n",
        "    -   Enumerating All Possibilities: In exhaustive search, the algorithm needs to evaluate every possible configuration to ensure the optimal solution is found. Each unique binary string corresponds to a specific candidate solution, so having the number of bits set enables the algorithm to enumerate all possible configurations.\n",
        "    -   Computational Complexity: The number of bits directly affects the computational complexity of exhaustive search. With $n$ bits, the search space grows exponentially, which is manageable for small $n$ but quickly becomes infeasible for larger $n$. By controlling the number of bits, you also control the practical feasibility of the exhaustive search.\n",
        "\n",
        "Simplicity: Since exhaustive search doesn’t involve complex heuristics or probabilistic methods, setting the number of bits becomes the main task. The rest of the algorithm is straightforward: generate each binary string, evaluate its objective value, and keep track of the best solution.\n"
      ],
      "id": "62370276"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Main execution\n",
        "num_bits = 10  # You can adjust the number of bits"
      ],
      "id": "f7f3dca4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Output\n"
      ],
      "id": "b81fba1c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Run the exhaustive search and get fitness values\n",
        "start_time = time.time()\n",
        "fitness_over_time, best_solution = run_exhaustive_search(num_bits)\n",
        "end_time = time.time()\n",
        "execution_time = end_time - start_time  # Calculate elapsed time\n",
        "\n",
        "# Output (O)\n",
        "print(f\"Exhaustive Search One-Max Time elapsed: {execution_time:.6f} seconds\")  # Print the elapsed time\n",
        "print(f\"# name of the search algorithm: Exhaustive Search\")\n",
        "print(f\"# number of bits: {num_bits}\")\n",
        "\n",
        "# Plot the evolution of fitness over time\n",
        "plt.figure(figsize=(10, 6))\n",
        "plt.plot(fitness_over_time, label='Fitness over time', color='blue', linewidth=2)\n",
        "plt.title(f'Exhaustive Search: Fitness Evolution ({num_bits} bits)')\n",
        "plt.xlabel('Evaluations')\n",
        "plt.ylabel('Fitness (Number of 1s)')\n",
        "plt.grid(True)\n",
        "plt.legend()\n",
        "plt.show()"
      ],
      "id": "5bb1962d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Ackley Function with ES\n",
        "\n",
        "-   Using exhaustive search with the Ackley function guarantees finding the global minimum because this method systematically evaluates every possible solution within a specified range, leaving no part of the search space unexplored. The Ackley function, known for its complex landscape with multiple local minima, has a known global minimum at zero when all inputs are zero, so an exhaustive search will eventually locate it by checking all candidate solutions.\n",
        "-   However, the drawback of exhaustive search is its high computational cost, especially in higher-dimensional spaces. The Ackley function’s input space grows exponentially with each additional dimension, making exhaustive search impractical beyond small problem sizes or low-dimensional cases. The method becomes computationally prohibitive because it must evaluate every point, which leads to a \"combinatorial explosion\" of possible solutions. This results in high time complexity and resource demands, making exhaustive search impractical for high-dimensional optimization tasks.\n",
        "-   In optimization, a 1D Ackley function is easier to model and solve than a 2D or 3D Ackley function primarily because of the exponential increase in the number of evaluations required as dimensionality rises. In 2D, the search space grows in a quadratic manner, meaning that an exhaustive search requires far fewer evaluations to cover the entire space, making it feasible to locate the global minimum with reasonable computational effort.\n",
        "-   When moving to 3D, however, the search space expands cubically. This additional dimension leads to a significant increase in the number of possible solution points, escalating the computational cost and making exhaustive search much less practical. In optimization, this curse of dimensionality complicates modeling since the function’s landscape becomes more intricate with each added dimension, and finding the global minimum among many potential local minima becomes increasingly challenging. Consequently, optimization techniques that are efficient in 2D may become impractically slow or require adaptation in 3D and beyond.\n",
        "-   The example below simplifies the Ackley function into 1D.\n"
      ],
      "id": "41717a38"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "## Ackley Function with Exhaustive Search\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import time\n",
        "\n",
        "# Ackley function definition\n",
        "def ackley(x):\n",
        "    a = 20\n",
        "    b = 0.2\n",
        "    c = 2 * np.pi\n",
        "    x = np.array(x)  \n",
        "    n = len(x)\n",
        "\n",
        "    term1 = -a * np.exp(-b * np.sqrt(np.sum(x**2) / n))\n",
        "    term2 = -np.exp(np.sum(np.cos(c * x)) / n)\n",
        "    return term1 + term2 + a + np.exp(1)\n",
        "\n",
        "# Initialization function (I)\n",
        "def init_es(search_range, step_size=0.1):\n",
        "    s = 0  # Initial solution\n",
        "    f_s = ackley([s])  # Evaluate initial solution\n",
        "    x_values = np.arange(search_range[0], search_range[1], step_size)  # Create the search space\n",
        "    return s, f_s, x_values\n",
        "\n",
        "# Transition function (T)\n",
        "def T(s, idx, x_values):\n",
        "    return x_values[idx]  # Move to the next solution\n",
        "\n",
        "# Evaluation function (E)\n",
        "def E(v):\n",
        "    return ackley([v])  # Evaluate the current solution\n",
        "\n",
        "# Determination function (D)\n",
        "def D(f_v, v, f_s, s):\n",
        "    if f_v < f_s:  # If new solution is better, update\n",
        "        s = v\n",
        "        f_s = f_v\n",
        "    return s, f_s\n",
        "\n",
        "# Exhaustive search function\n",
        "def exhaustive_search(search_range, step_size=0.1):\n",
        "    # Initialize using init_es\n",
        "    s, f_s, x_values = init_es(search_range, step_size)\n",
        "    \n",
        "    # While the termination criterion is not met\n",
        "    idx = 0\n",
        "    while idx < len(x_values):\n",
        "        # Generate the next solution v using transition (T)\n",
        "        v = T(s, idx, x_values)   \n",
        "        # Evaluate the new solution\n",
        "        f_v = E(v)  \n",
        "        # Determine if the new solution is better\n",
        "        s, f_s = D(f_v, v, f_s, s)\n",
        "        # Move to the next solution\n",
        "        idx += 1\n",
        "    \n",
        "    # Return the best solution found\n",
        "    return s, f_s, x_values\n",
        "\n",
        "# Main Execution\n",
        "# Perform exhaustive search with the Ackley function over the range [-10, 10]\n",
        "start_time = time.time()\n",
        "optimal_x_exhaustive, optimal_value_exhaustive, x_values = exhaustive_search((-10, 10))\n",
        "end_time = time.time()\n",
        "execution_time = end_time - start_time  # Calculate elapsed time\n",
        "\n",
        "# Output (O)\n",
        "print(f\"Optimal x: {optimal_x_exhaustive}\")\n",
        "print(f\"Optimal value: {optimal_value_exhaustive}\")\n",
        "print(f\"Exhaustive Search Ackley Function Execution time: {execution_time:.6f} seconds\")\n",
        "\n",
        "# Plot the Ackley function and exhaustive search results\n",
        "y_values = [ackley([x]) for x in x_values]\n",
        "plt.plot(x_values, y_values, label=\"Ackley Function\", color='b')\n",
        "plt.scatter([optimal_x_exhaustive], [optimal_value_exhaustive], color='red', label='Optimal Point (Exhaustive Search)')\n",
        "plt.title(\"Ackley Function in 1D with Exhaustive Search\")\n",
        "plt.xlabel(\"x\")\n",
        "plt.ylabel(\"f(x)\")\n",
        "plt.axhline(0, color='gray', linestyle='--')\n",
        "plt.axvline(0, color='gray', linestyle='--')\n",
        "plt.legend()\n",
        "plt.grid(True)\n",
        "plt.show()"
      ],
      "id": "0ebedbab",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   Overall, the output confirms the accuracy and efficiency of the search in this specific case, identifying the minimum accurately in a very short time.\n",
        "-   Optimal x: The search identified $x=0$ as the value that minimizes the Ackley function at 0. Since the Ackley function's global minimum is known to occur at zero (specifically, at $x=0$ for each input variable), this result confirms the function’s minimum in this search.\n",
        "-   Optimal value: This is the computed minimum value of the Ackley function at $x=0$. This very small number, so close to zero but slightly above due to computational limitations or floating-point precision. It’s effectively zero for practical purposes, indicating the function reached its theoretical minimum.\n",
        "-   Execution time: 0.002003 seconds – The exhaustive search took just over 2 milliseconds to complete. This quick time suggests that the search was likely performed in a low-dimensional space (such as 1D or 2D), where an exhaustive approach can be executed efficiently. In higher dimensions, exhaustive search would generally take significantly longer due to the exponential increase in the number of points to evaluate.\n",
        "\n",
        "# Comparing One Max to Ackley\n",
        "\n",
        "-   Initialization() Function: In an exhaustive search on the Ackley function, a step size is essential because the Ackley function operates in a continuous space, meaning the variables can take any real value within a defined range. The step size determines the resolution of the search, dictating how closely spaced the evaluation points are. A finer step size means more precise exploration of the function's landscape, potentially identifying the global minimum more accurately, but at the cost of increased computation. Without a defined step size, exhaustive search would theoretically require an infinite number of evaluations, as there are infinitely many points in a continuous space. In contrast, the One Max problem typically operates in a discrete binary space (e.g., binary strings), where each variable can only take values of 0 or 1. This structure doesn’t require a step size, as all possible solutions are already discrete and finite. Each solution is a unique binary string, and the exhaustive search simply evaluates every possible string without needing to subdivide the space further.\n",
        "-   Transition() Function: In the Ackley function, when you define a function like $T(s, idx, x_values)$ and use return x_values\\[idx\\], you are treating the search space as a continuous or discretized array of possible values. Here, x_values is typically a list or array containing the potential values for each variable dimension, and idx simply indexes into this array to retrieve a specific value. Since exhaustive search involves systematically testing all possible values in x_values, there’s no need for incremental addition $(s += 1)$; instead, the function directly retrieves the next possible value at a given index, which is common in continuous or multi-valued spaces. In contrast, the One Max problem is a binary optimization problem where the goal is to maximize the sum of binary values (0s and 1s). The search space consists of binary strings rather than a continuous or finely discretized set. Incrementing $s$ (like $s += 1$) in this context might be used to iterate over binary configurations or to shift values systematically, as each configuration can only be either a 0 or a 1. This incremental approach is necessary in One Max because there is no list of predefined values (like x_values); rather, each binary position in the solution must be systematically altered to generate each possible solution.\n",
        "-   Evaluation() Function: E(v) in the Ackley function evaluates continuous real values for minimization, while bin(s).count(\"1\") in the One Max problem evaluates binary integers for maximization. A lower evaluation result from E(v) indicates a better solution in terms of proximity to the global minimum while a higher count of \"1\"s in bin(s).count(\"1\") represents a better solution, as it means the solution is closer to the optimal binary string of all 1s.\n",
        "-   Determine() Function: In one max, we want to maximize. In Ackley, we want to minimize. This affects the determination function: if f_v \\< f_s (for minimize) vs f_v \\> f_s (for maximize)\n",
        "\n",
        "# Using AI\n",
        "\n",
        "-   Use the following prompt on a generative AI, like chatGPT, to learn more about the topics covered.\n",
        "-   Concept of Exhaustive Search: Explain, in your own words, what an exhaustive search is and how it systematically explores all possible solutions. Why is this method guaranteed to find the optimal solution?\n",
        "-   Advantages and Limitations: Discuss the advantages and disadvantages of using exhaustive search for solving optimization problems. When would you avoid using it?\n",
        "-   Comparison with Heuristics: Compare exhaustive search with heuristic methods (like greedy algorithms). When would you prioritize optimality over computational efficiency?\n",
        "-   Greedy vs. Exhaustive: Reflect on a problem where you would instinctively use a greedy approach but later realize an exhaustive search would yield a better result. What changed your decision?\n",
        "-   Continuous vs Discrete Domains: Discuss how exhaustive search differs when applied to continuous domains (e.g., Ackley function) versus discrete domains (e.g., knapsack problem). Why does step size matter in continuous optimization?\n",
        "-   Trade-Offs in Optimization: Reflect on a scenario where exhaustive search would be impractical. How would you modify the problem or approach to make it solvable within reasonable time and resources?\n",
        "-   Visualization Insights: How does visualizing the search process (e.g., fitness evolution over time) help in understanding and debugging optimization algorithms?\n",
        "\n",
        "# Conclusions\n",
        "\n",
        "-   Choose exhaustive search for small-scale problems where optimality is critical. Use heuristics for large, complex, or high-dimensional spaces."
      ],
      "id": "664823be"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}